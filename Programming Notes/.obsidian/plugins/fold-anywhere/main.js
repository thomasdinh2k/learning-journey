/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/foldAnyWhereIndex.ts
var foldAnyWhereIndex_exports = {};
__export(foldAnyWhereIndex_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(foldAnyWhereIndex_exports);
var import_obsidian2 = require("obsidian");

// src/widgets/foldService.ts
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
function createFoldRangesFromCurrentPOS(state, currentPos) {
  const startRegex = /\B%%\s+REGION\s+%%\B/g;
  const endRegex = /\B%%\s+ENDREGION\s+%%\B/g;
  let ranges = [];
  let startStack = [];
  let currentLine = state.doc.lineAt(currentPos);
  for (let i = currentLine.number; i <= state.doc.lines; i++) {
    const line = state.doc.line(i);
    startRegex.lastIndex = 0;
    endRegex.lastIndex = 0;
    let tempStartPositions = [];
    let match;
    while ((match = startRegex.exec(line.text)) !== null) {
      tempStartPositions.push(line.from + match.index);
    }
    if (tempStartPositions.length > 1) {
      tempStartPositions.forEach((pos) => startStack.push(pos));
    } else if (tempStartPositions.length === 1) {
      startStack.push(tempStartPositions[0]);
    }
    let endMatch;
    while ((endMatch = endRegex.exec(line.text)) !== null) {
      let endPosition = line.from + endMatch.index + endMatch[0].length;
      if (startStack.length) {
        let start = startStack.pop();
        if (start !== void 0 && start < currentPos) {
          ranges.push({ from: start, to: endPosition });
        }
      } else {
        for (let j = i - 1; j >= 1; j--) {
          const searchLine = state.doc.line(j);
          startRegex.lastIndex = 0;
          if (endRegex.test(searchLine.text)) {
            break;
          }
          let startMatch;
          if ((startMatch = startRegex.exec(searchLine.text)) !== null) {
            ranges.push({ from: searchLine.from + startMatch.index, to: endPosition });
            break;
          }
        }
      }
      if (ranges.length > 0 && startStack.length === 0) {
        break;
      }
    }
  }
  const validRanges = ranges.filter((range) => range.from < currentPos && range.to > currentPos);
  validRanges.sort((a, b) => a.to - a.from - (b.to - b.from));
  return validRanges.length > 0 ? validRanges.slice(0, 1) : [];
}
function findMatchingFoldRange(state, currentPos) {
  const startRegex = /\B%%\s+REGION\s+%%\B/g;
  const endRegex = /\B%%\s+ENDREGION\s+%%\B/g;
  let startStack = [];
  let currentLine = state.doc.lineAt(currentPos);
  for (let i = currentLine.number; i <= state.doc.lines; i++) {
    const line = state.doc.line(i);
    startRegex.lastIndex = 0;
    endRegex.lastIndex = 0;
    let match;
    while ((match = startRegex.exec(line.text)) !== null) {
      startStack.push(line.from + match.index);
    }
    if (i === currentLine.number && startStack.length === 0) {
      return null;
    }
    let endMatch;
    while ((endMatch = endRegex.exec(line.text)) !== null && startStack.length) {
      let start = startStack.pop();
      let endPosition = line.from + endMatch.index + endMatch[0].length;
      if (startStack.length === 0) {
        return { from: start, to: endPosition };
      }
    }
  }
  return null;
}
function getAllFoldableRanges(state) {
  const startRegex = /\B%%\s+REGION\s+%%\B/g;
  const endRegex = /\B%%\s+ENDREGION\s+%%\B/g;
  let ranges = [];
  let startStack = [];
  for (let i = 1; i <= state.doc.lines; i++) {
    const line = state.doc.line(i);
    startRegex.lastIndex = 0;
    endRegex.lastIndex = 0;
    let match;
    while ((match = startRegex.exec(line.text)) !== null) {
      startStack.push(line.from + match.index);
    }
    if (endRegex.test(line.text) && startStack.length) {
      let start = startStack.pop();
      if (start !== void 0) {
        ranges.push({ from: start, to: line.to });
      }
    }
  }
  return ranges;
}
function foldServiceFunc(state, lineStart, lineEnd) {
  let range = findMatchingFoldRange(state, lineStart);
  if (!range)
    return null;
  return range;
}
var foldRanges = import_state.StateField.define({
  create: (state) => getAllFoldableRanges(state),
  update(value, tr) {
    return value;
  }
});
var FoldingExtension = [
  (0, import_language.codeFolding)({
    placeholderDOM(view, onclick) {
      const placeholder = createEl("span", {
        text: "...",
        cls: "cm-foldPlaceholder"
      });
      placeholder.onclick = onclick;
      return placeholder;
    }
  }),
  foldRanges,
  import_language.foldService.of(foldServiceFunc)
];
function foldAll(view) {
  var _a, _b;
  const ranges = createFoldRangesFromCurrentPOS(view.state, view.state.selection.main.head);
  if (ranges.length > 0) {
    const effects = ranges.map((range) => import_language.foldEffect.of(range));
    view.dispatch({ effects });
    view.dispatch({
      selection: { anchor: ((_a = ranges.last()) == null ? void 0 : _a.to) || 0, head: ((_b = ranges.last()) == null ? void 0 : _b.to) || 0 }
    });
  }
}
function unfoldAll(view) {
  const ranges = createFoldRangesFromCurrentPOS(view.state, view.state.selection.main.head);
  if (ranges.length > 0) {
    const effects = ranges.map((range) => import_language.unfoldEffect.of(range));
    view.dispatch({ effects });
  }
}
var foldService_default = FoldingExtension;

// src/widgets/foldMarkerWidget.ts
var import_view = require("@codemirror/view");
var import_obsidian = require("obsidian");
var FoldMarkWidget = class extends import_view.WidgetType {
  constructor(app, view, from, to, markType = "fold", isFolded = false) {
    super();
    this.app = app;
    this.view = view;
    this.from = from;
    this.to = to;
    this.markType = markType;
    this.isFolded = isFolded;
  }
  eq(other) {
    return other.view === this.view && other.from === this.from && other.to === this.to;
  }
  toDOM() {
    const creaseEl = createSpan("cm-fold-anywhere-icon");
    const iconEl = creaseEl.createSpan(this.markType === "fold" ? "fold-start" : "fold-end");
    let title, icon;
    if (this.markType === "fold") {
      title = "Remove Fold Start Mark";
      icon = this.isFolded ? "goal" : "chevron-last";
    } else {
      title = "Remove Fold End Mark";
      icon = "chevron-first";
    }
    (0, import_obsidian.setIcon)(iconEl, icon);
    creaseEl.addEventListener("click", (evt) => {
      if (evt.ctrlKey || evt.metaKey) {
        const menu = new import_obsidian.Menu();
        menu.addItem((item) => item.setTitle(title).setIcon("x").onClick(() => {
          this.view.dispatch({
            changes: {
              from: this.from,
              to: this.to,
              insert: ""
            }
          });
        })).showAtMouseEvent(evt);
        return;
      }
      this.view.dispatch({
        selection: { anchor: (this.markType === "fold" ? this.to : this.from) || 0, head: (this.markType === "fold" ? this.to : this.from) || 0 }
      });
      foldAll(this.view);
    });
    return creaseEl;
  }
  ignoreEvent(event) {
    return false;
  }
};
function foldAllPlugin(app) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = import_view.Decoration.none;
      this.allDecos = import_view.Decoration.none;
      this.decorator = new import_view.MatchDecorator({
        regexp: /\B%%\s+(REGION|ENDREGION)\s+%%\B/g,
        decoration: this.getDeco.bind(this)
      });
      this.decorations = this.decorator.createDeco(view);
    }
    getDeco(match, _view, pos) {
      const from = pos;
      const to = pos + match[0].length;
      return import_view.Decoration.replace({
        widget: new FoldMarkWidget(app, this.view, from, to, match[1] === "REGION" ? "fold" : "unfold")
      });
    }
    update(update) {
      if (!update.state.field(import_obsidian.editorLivePreviewField)) {
        this.decorations = import_view.Decoration.none;
        return;
      }
      this.decorations = this.decorator.updateDeco(update, this.decorations);
    }
  }, {
    decorations: (v) => v.decorations,
    provide: (plugin) => import_view.EditorView.atomicRanges.of((view) => {
      var _a;
      return ((_a = view.plugin(plugin)) == null ? void 0 : _a.decorations) || import_view.Decoration.none;
    })
  });
}

// src/utils/line.ts
var MARKLIST = {
  start: "%% REGION %%",
  end: "%% ENDREGION %%"
};
var BLOCK_ID_REGEX = /\^[a-zA-Z0-9\-]{1,6}$/g;
var checkStartOrEnd = (editor) => {
  const fromCursor = editor.getCursor("from");
  const toCursor = editor.getCursor("to");
  const lineStart = fromCursor.ch === 0 || editor.getLine(fromCursor.line).charAt(fromCursor.ch - 1) === " ";
  const lineEnd = toCursor.ch === editor.getLine(toCursor.line).length || editor.getLine(toCursor.line).charAt(toCursor.ch) === " ";
  return { lineStart, lineEnd, toCursor };
};
var insertEndMarkBeforeBlockID = (content) => {
  const match = content.match(BLOCK_ID_REGEX);
  if (match) {
    return content.replace(BLOCK_ID_REGEX, `%% ENDREGION %% ${match[0]}`);
  } else {
    return content + ` %% ENDREGION %%`;
  }
};
var dealWithSelection = (editor) => {
  const selection = editor.getSelection();
  if (selection.trim().length === 0)
    return;
  const { lineStart, lineEnd, toCursor } = checkStartOrEnd(editor);
  editor.replaceSelection((lineStart ? `` : ` `) + `%% REGION %% ${insertEndMarkBeforeBlockID(selection.trim())}` + (lineEnd ? `` : ` `));
  editor.setCursor(toCursor.line, toCursor.ch + 14);
  foldAll(editor.cm);
};
var insertMark = (editor, type) => {
  const selection = editor.getSelection();
  if (selection.trim().length > 0)
    return;
  const { lineStart, lineEnd } = checkStartOrEnd(editor);
  editor.replaceSelection((lineStart ? `` : ` `) + MARKLIST[type] + (lineEnd ? type === "start" ? ` ` : `` : ` `));
};

// src/foldAnyWhereIndex.ts
var MyPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    this.registerIcons();
    this.registerCommands();
    this.registerContextMenu();
    this.registerEditorExtension([foldService_default, foldAllPlugin(this.app)]);
  }
  onunload() {
  }
  registerIcons() {
    (0, import_obsidian2.addIcon)("fold-horizontal", `<g xmlns="http://www.w3.org/2000/svg" id="surface1"><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 1.999687 12 L 7.999687 12 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 22.000312 12 L 16.000312 12 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 12 1.999687 L 12 4.000312 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 12 7.999687 L 12 10.000312 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 12 13.999688 L 12 16.000312 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 12 19.999688 L 12 22.000312 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 19.000312 9 L 16.000312 12 L 19.000312 15 " transform="matrix(4.166667,0,0,4.166667,0,0)"/><path style="fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:4;" d="M 4.999687 15 L 7.999687 12 L 4.999687 9 " transform="matrix(4.166667,0,0,4.166667,0,0)"/></g>`);
  }
  registerCommands() {
    this.addCommand({
      id: "fold-current-range",
      name: "Fold Between Start and End Marks",
      editorCallback: (editor) => {
        const editorView = editor.cm;
        foldAll(editorView);
      }
    });
    this.addCommand({
      id: "unfold-current-range",
      name: "Unfold Between Start and End Marks",
      editorCallback: (editor) => {
        const editorView = editor.cm;
        unfoldAll(editorView);
      }
    });
    this.addCommand({
      id: "fold-selected-text",
      name: "Fold Selected Text",
      editorCallback: (editor) => dealWithSelection(editor)
    });
    this.addCommand({
      id: "mark-as-start",
      name: "Mark as Start",
      editorCallback: (editor) => insertMark(editor, "start")
    });
    this.addCommand({
      id: "mark-as-end",
      name: "Mark as End",
      editorCallback: (editor) => insertMark(editor, "end")
    });
    this.addCommand({
      id: "remove-all-markers",
      name: "Remove All Markers In Current File",
      callback: async () => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if (markdownView) {
          const file = markdownView.file;
          if (!file)
            return;
          let ready = false;
          new AskModal(this.app, async (already) => {
            ready = already;
            if (ready) {
              const fileContent = await this.app.vault.cachedRead(file);
              const newFileContent = fileContent.replace(/(\s)?%% REGION %%|(\s)?%% ENDREGION %%/g, "");
              await this.app.vault.modify(file, newFileContent);
            }
          }).open();
          return;
        }
        new import_obsidian2.Notice("No active file open");
      }
    });
  }
  registerContextMenu() {
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor) => {
      if (!editor) {
        return;
      }
      const selection = editor.getSelection();
      menu.addItem((item) => {
        const subMenu = item.setSection("action").setTitle(`Fold AnyWhere`).setIcon("chevrons-right-left").setSubmenu();
        subMenu.addItem((item2) => {
          item2.setIcon("fold-horizontal").setTitle("Fold Selected Text").setDisabled(!selection.trim()).onClick(() => dealWithSelection(editor));
        });
        subMenu.addItem((item2) => {
          item2.setIcon("chevron-last").setTitle("Mark as Start").setDisabled(!!selection.trim()).onClick(() => insertMark(editor, "start"));
        });
        subMenu.addItem((item2) => {
          item2.setIcon("chevron-first").setTitle("Mark as End").setDisabled(!!selection.trim()).onClick(() => insertMark(editor, "end"));
        });
      });
    }));
  }
};
var AskModal = class extends import_obsidian2.Modal {
  constructor(app, cb) {
    super(app);
    this.cb = cb;
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.toggleClass("fold-anywhere-ask-modal", true);
    contentEl.createEl("div", { text: "Are you sure?" });
    const buttonContainer = contentEl.createDiv({ cls: "button-container" });
    new import_obsidian2.ButtonComponent(buttonContainer).setClass("remove-ready").setWarning().setButtonText("Yes").onClick(async () => {
      await this.cb(true);
      this.close();
    });
    new import_obsidian2.ButtonComponent(buttonContainer).setClass("do-not-remove").setButtonText("No").onClick(async () => {
      await this.cb(false);
      this.close();
    });
  }
};
